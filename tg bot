import telebot
import datetime
import time
import threading
from telebot import types

temporary_event_names = dict()
completed_constant_event_names = list()
incomplete_constant_event_names = list()
bot = telebot.TeleBot('6662439465:AAFIY1nxwPtnB1cv0zp4T5GEdlmBKgEoGdc')


@bot.message_handler(commands=['temporary_events_status'])
def temporary_events_status(message):
    try:
        value_list = list(temporary_event_names.values())
        key_list = list(temporary_event_names.keys())
        if len(key_list) > 0:
            for i in range(len(key_list)):
                bot.send_message(message.chat.id, f'Событие {key_list[i]} длилось - {value_list[i]}')
        else:
            bot.send_message(message.chat.id, 'Ошибка, У вас нет временных событий')
    except ValueError:
        bot.send_message(message.chat.id, 'Ошибка, попробуйте снова')


@bot.message_handler(commands=['constant_events_status'])
def constant_events_status(message):
    try:
        comp = completed_constant_event_names[:]
        incomp = incomplete_constant_event_names[:]
        if len(comp) > 0:
            bot.send_message(message.chat.id, 'Завершённые события:')
            for i in range(len(comp)):
                bot.send_message(message.chat.id, f'{i + 1}) {comp[i]}')
        else:
            bot.send_message(message.chat.id, 'Ошибка, У вас нет завершённых событий')
        if len(incomp) > 0:
            bot.send_message(message.chat.id, 'Незавершённые события:')
            for i in range(len(incomp)):
                bot.send_message(message.chat.id, f'{i + 1}) {incomp[i]}')
        else:
            bot.send_message(message.chat.id, 'Ошибка, Все существующие события были завершены')
    except ValueError:
        bot.send_message(message.chat.id, 'Ошибка, попробуйте снова')


@bot.message_handler(commands=['start'])
def start_message(message):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    btn1 = types.KeyboardButton("Привет")
    btn2 = types.KeyboardButton("Задать вопрос")
    btn3 = types.KeyboardButton("Создать временное событие")
    btn6 = types.KeyboardButton("Создать постоянное событие")

    markup.add(btn1, btn2, btn3, btn6)
    bot.send_message(message.chat.id,
                     "Привет, {0.first_name}! Это бот Трэкер задач, он отслеживает длительность тех или "
                     "иных действий)".format(message.from_user),
                     reply_markup=markup)


@bot.message_handler(commands=['temporary_event'])
def temporary_event_message(message):
    # Запрашиваем у пользователя название события и дату и время события
    bot.send_message(message.chat.id, 'Введите название события:')
    bot.register_next_step_handler(message, set_temporary_event_name)


def set_temporary_event_name(message):
    user_data = {}
    user_data[message.chat.id] = {'event_name': message.text}
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    btn3 = types.KeyboardButton("Создать временное событие")
    back = types.KeyboardButton("Вернуться в главное меню")
    markup.add(back, btn3)
    if (message.text == "Вернуться в главное меню"):
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        button1 = types.KeyboardButton("Привет")
        button2 = types.KeyboardButton("Задать вопрос")
        button3 = types.KeyboardButton("Создать временное событие")
        button4 = types.KeyboardButton("Создать постоянное событие")
        markup.add(button1, button2, button3, button4)
        bot.send_message(message.chat.id, text="Вы вернулись в главное меню", reply_markup=markup)

    elif (message.text == "Создать временное событие"):
        temporary_event_message(message)

    elif (message.text == "Создать постоянное событие"):
        constant_event_message(message)

    bot.send_message(message.chat.id,
                     "Введите дату и время, когда вы хотите получить событие в формате ГГГГ-ММ-ДД чч:мм:сс.".format(
                         message.from_user),
                     reply_markup=markup)
    curr_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())
    bot.send_message(message.chat.id, f'Например {curr_time}')
    bot.register_next_step_handler(message, temporary_event_set, user_data)


def temporary_event_set(message, user_data):
    try:
        event_time = datetime.datetime.strptime(message.text, '%Y-%m-%d %H:%M:%S')
        now = datetime.datetime.now()
        delta = event_time - now
        if delta.total_seconds() <= 0:
            bot.send_message(message.chat.id, 'Вы ввели прошедшую дату, попробуйте создать событие еще раз.')
        else:
            event_name = user_data[message.chat.id]['event_name']
            bot.send_message(message.chat.id,
                             'Событие "{}" установлено на {}.'.format(event_name, event_time))
            event_timer = threading.Timer(delta.total_seconds(), send_temporary_event, [message.chat.id, event_name])
            event_timer.start()
            temporary_event_names[event_name] = delta
    except ValueError:
        bot.send_message(message.chat.id,
                         'Вы ввели неверный формат даты и времени, попробуйте создать событие еще раз.')


@bot.message_handler(commands=['del_event'])
def event_del(message):
    bot.send_message(message.chat.id, 'Введите название события которое нужно удалить:')
    bot.register_next_step_handler(message, del_temporary_events)


def del_temporary_events(message):
    try:
        user_data = {}
        user_data[message.chat.id] = {'event_for_del': message.text}
        if message.text not in temporary_event_names:
            bot.send_message(message.chat.id, 'Такого события нет')
        else:
            bot.send_message(message.chat.id, f'Событие {message.text} удалено')
            del temporary_event_names[message.text]

    except ValueError:
        bot.send_message(message.chat.id, 'Возможно вы ввели неправильное название события')


def send_temporary_event(chat_id, event_name):
    bot.send_message(chat_id, 'Внимание! Наступило событие "{}"!'.format(event_name))


@bot.message_handler(commands=['constant_event'])
def constant_event_message(message):
    # Запрашиваем у пользователя название события
    bot.send_message(message.chat.id, 'Введите название события:')
    bot.register_next_step_handler(message, set_constant_event_name)


def set_constant_event_name(message):
    user_data = {}
    user_data[message.chat.id] = {'event_name': message.text}
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    btn3 = types.KeyboardButton("Создать постоянное событие")
    back = types.KeyboardButton("Вернуться в главное меню")
    markup.add(back, btn3)
    if (message.text == "Вернуться в главное меню"):
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        button1 = types.KeyboardButton("Привет")
        button2 = types.KeyboardButton("Задать вопрос")
        button3 = types.KeyboardButton("Создать временное событие")
        button4 = types.KeyboardButton("Создать постоянное событие")
        markup.add(button1, button2, button3, button4)
        bot.send_message(message.chat.id, text="Вы вернулись в главное меню", reply_markup=markup)
    elif (message.text == "Создать временное событие"):
        temporary_event_message(message)
    elif (message.text == "Создать постоянное событие"):
        constant_event_message(message)
    bot.register_next_step_handler(message, constant_event_set, user_data)


def constant_event_set(message, user_data):
    event_name = user_data[message.chat.id]['event_name']
    bot.send_message(message.chat.id,
                     'Событие "{}" создано'.format(event_name))
    incomplete_constant_event_names.append(event_name)


@bot.message_handler(commands=['del_constant_event'])
def constant_event_del(message):
    bot.send_message(message.chat.id, 'Введите название события которое нужно удалить:')
    bot.register_next_step_handler(message, del_constant_events)


def del_constant_events(message):
    try:
        if message.text not in incomplete_constant_event_names or message.text not in completed_constant_event_names:
            bot.send_message(message.chat.id, 'Такого события нет')
        else:
            bot.send_message(message.chat.id, f'Событие {message.text} удалено')
            if message.text in incomplete_constant_event_names:
                del incomplete_constant_event_names[message.text]
            elif message.text in incomplete_constant_event_names:
                del completed_constant_event_names[message.text]

    except ValueError:
        bot.send_message(message.chat.id, 'Возможно вы ввели неправильное название события')


@bot.message_handler(commands=['complete_event'])
def complete_event(message):
    bot.send_message(message.chat.id, 'Введите название события которое нужно выполнить:')
    bot.register_next_step_handler(message, complete_any_event)


def complete_any_event(message):
    try:
        if message.text not in incomplete_constant_event_names:
            bot.send_message(message.chat.id, 'Такого события нет')
        else:
            bot.send_message(message.chat.id, f'Событие {message.text} выполнено')
            i = incomplete_constant_event_names.index(message.text)
            del incomplete_constant_event_names[i]
            completed_constant_event_names.append(message.text)
    except ValueError:
        bot.send_message(message.chat.id, 'Возможно вы ввели неправильное название события')


@bot.message_handler(content_types=['text'])
def func(message):
    if (message.text == "Привет"):
        bot.send_message(message.chat.id, text="Привет :)")

    elif (message.text == "Список временных событий"):
        temporary_events_status(message)

    elif (message.text == "Завершить событие"):
        complete_event(message)

    elif (message.text == "Список постоянных событий"):
        constant_events_status(message)

    elif (message.text == "Создать временное событие"):
        temporary_event_message(message)

    elif (message.text == "Создать постоянное событие"):
        constant_event_message(message)

    elif (message.text == "Задать вопрос"):
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        btn1 = types.KeyboardButton("Как тебя зовут?")
        btn2 = types.KeyboardButton("Что ты можешь?")
        back = types.KeyboardButton("Вернуться в главное меню")
        markup.add(btn1, btn2, back)
        bot.send_message(message.chat.id, text="Задай мне вопрос", reply_markup=markup)

    elif (message.text == "Как тебя зовут?"):
        bot.send_message(message.chat.id, "У меня... нет имени :(")

    elif message.text == "Что ты можешь?":
        bot.send_message(message.chat.id, "1)Поздороваться с тобой")
        bot.send_message(message.chat.id, "2)Создать событие")
        bot.send_message(message.chat.id, 'Чтобы создать временное событие, введи /temporary_event.')
        bot.send_message(message.chat.id, 'Чтобы создать постоянное событие, введи /constant_event.')
        bot.send_message(message.chat.id,
                         'Чтобы посмотреть на список временных событий, введи /temporary_events_status')
        bot.send_message(message.chat.id,
                         'Чтобы посмотреть на список постоянных событий, введи /constant_events_status')
        bot.send_message(message.chat.id, 'Чтобы удалить временное событие, введи /del_temporary_event.')
        bot.send_message(message.chat.id, 'Чтобы удалить постоянное событие, введи /del_constant_event.')

    elif (message.text == "Вернуться в главное меню"):
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        button1 = types.KeyboardButton("Привет")
        button2 = types.KeyboardButton("Задать вопрос")
        button6 = types.KeyboardButton("Создать временное событие")
        button3 = types.KeyboardButton("Создать постоянное событие")
        button4 = types.KeyboardButton("Список временных событий")
        button5 = types.KeyboardButton("Список постоянных событий")
        button7 = types.KeyboardButton("Завершить событие")
        markup.add(button1, button2, button3, button4, button5, button6, button7)
        bot.send_message(message.chat.id, text="Вы вернулись в главное меню", reply_markup=markup)


if __name__ == '__main__':
    bot.infinity_polling()
